<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Animation - Dinh Luong Ta</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="galaxyCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById("galaxyCanvas");
    const container = document.getElementById("canvas-container");
    const ctx = canvas.getContext("2d");

    /* ===== CONFIG & ASSETS ===== */
    const TEXT_STR = "DINH LUONG TA";
    // Thay thế các đường dẫn ảnh của bạn vào đây
    const imageSources = [ "luen_logo.png", "hexagon-main.png", "luen-1.jpg", ];

    let w, h, cx, cy;
    let zoom = 0.45;
    const PERSPECTIVE = 1500;
    let rotX = 2.0;
    let rotY = 0;

    const PLANET_RADIUS = 120;
    const IMAGE_SHOW_SCALE = 0.85;
    const ORBIT_RADIUS = 240; 
    const ORBIT_TILT = -80;   

    const PARTICLE_TILT_X = Math.PI / 2.5; 
    const PARTICLE_TILT_Z = Math.PI / 6;

    /* ===== LOAD IMAGES ===== */
    const images = imageSources.map(src => {
        const img = new Image();
        img.src = src;
        return img;
    });

    const rand = (a, b) => Math.random() * (b - a) + a;

    /* ===== RESIZE ===== */
    function resize() {
        w = canvas.width = container.clientWidth;
        h = canvas.height = container.clientHeight;
        cx = w / 2;
        cy = h / 2;
    }

    /* ===== 3D HELPERS ===== */
    function rotate3D(x, y, z) {
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);
        return { x: x2, y: y1, z: z2 };
    }

    function project(p) {
        const s = (PERSPECTIVE / (PERSPECTIVE + p.z)) * zoom;
        return { x: cx + p.x * s, y: cy + p.y * s, s, z: p.z };
    }

    /* ===== OBJECTS SETUP ===== */
    const stars = Array.from({ length: 800 }, () => ({
        x: rand(-w * 3, w * 3),
        y: rand(-h * 3, h * 3),
        z: rand(-3000, 3000),
        r: Math.random() * 1.5,
        a: Math.random() * Math.PI * 2
    }));

    const particles = [];
    const particleCount = 1500;
    for (let i = 0; i < particleCount; i++) {
        particles.push({
            radius: rand(220, 650),
            angle: Math.random() * Math.PI * 2,
            speed: rand(0.001, 0.003),
            yOffset: rand(-15, 15),
            size: rand(2, 5),
            imgIndex: Math.floor(Math.random() * images.length)
        });
    }

    /* ===== INTERACTION ===== */
    let dragging = false;
    let lastX = 0, lastY = 0;
    let initialPinchDistance = null;

    canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        zoom += e.deltaY * -0.0005;
        zoom = Math.max(0.2, Math.min(6, zoom));
    }, { passive: false });

    canvas.addEventListener("mousedown", (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        rotY += (e.clientX - lastX) * 0.003;
        rotX += (e.clientY - lastY) * 0.003;
        lastX = e.clientX; lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => { dragging = false; });

    // Touch support
    canvas.addEventListener("touchstart", (e) => {
        if(e.touches.length === 1) {
            dragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDistance = Math.sqrt(dx*dx + dy*dy);
        }
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if(e.touches.length === 1 && dragging) {
            rotY += (e.touches[0].clientX - lastX) * 0.003;
            rotX += (e.touches[0].clientY - lastY) * 0.003;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2 && initialPinchDistance) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const newDist = Math.sqrt(dx*dx + dy*dy);
            zoom *= newDist / initialPinchDistance;
            zoom = Math.max(0.2, Math.min(6, zoom));
            initialPinchDistance = newDist;
        }
    }, { passive: false });

    window.addEventListener("resize", resize);
    resize();

    /* ===== DRAW LOOP ===== */
    let time = 0;
    function draw() {
        time += 0.003;
        ctx.clearRect(0, 0, w, h);

        // 1. Background
        const bg = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w,h));
        bg.addColorStop(0, "#050010");
        bg.addColorStop(1, "#000");
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, w, h);

        // 2. Stars
        ctx.fillStyle = "#fff";
        stars.forEach(s => {
            const p = project(rotate3D(s.x, s.y, s.z));
            ctx.globalAlpha = 0.3 + Math.sin(s.a + time*5)*0.3;
            ctx.fillRect(p.x, p.y, s.r*p.s, s.r*p.s);
        });
        ctx.globalAlpha = 1;

        const renderList = [];

        // Planet
        const planetPos = rotate3D(0, 0, 0);
        renderList.push({ type: 'planet', z: planetPos.z, x: planetPos.x, y: planetPos.y });

        // Particles
        particles.forEach(p => {
            const currentA = p.angle + time + (time * p.speed * 100); 
            let px = p.radius * Math.cos(currentA);
            let pz = p.radius * Math.sin(currentA);
            let py = p.yOffset;

            let y1 = py * Math.cos(PARTICLE_TILT_X) - pz * Math.sin(PARTICLE_TILT_X);
            let z1 = py * Math.sin(PARTICLE_TILT_X) + pz * Math.cos(PARTICLE_TILT_X);
            let x2 = px * Math.cos(PARTICLE_TILT_Z) - y1 * Math.sin(PARTICLE_TILT_Z);
            let y2 = px * Math.sin(PARTICLE_TILT_Z) + y1 * Math.cos(PARTICLE_TILT_Z);
            
            const r = rotate3D(x2, y2, z1); // Using z1 from first rotation
            renderList.push({ type: 'particle', z: r.z, x: r.x, y: r.y, original: p });
        });

        // Text
        for(let i = 0; i < TEXT_STR.length; i++){
            const a = time * 2 + i * 0.35;
            const tx = Math.cos(a) * ORBIT_RADIUS;
            const tz = Math.sin(a) * ORBIT_RADIUS;
            const ty = Math.sin(a) * ORBIT_TILT;
            const r = rotate3D(tx, ty, tz);
            renderList.push({ type: 'text', z: r.z, x: r.x, y: r.y, char: TEXT_STR[i] });
        }

        renderList.sort((a, b) => b.z - a.z);

        renderList.forEach(item => {
            const p = project(item);
            if(p.s <= 0) return;

            if (item.type === 'planet') {
                const planetR = PLANET_RADIUS * p.s;
                const g = ctx.createRadialGradient(p.x - 40 * p.s, p.y - 40 * p.s, 20 * p.s, p.x, p.y, planetR);
                g.addColorStop(0, "#ffd1ff");
                g.addColorStop(0.5, "#ff8ad4");
                g.addColorStop(1, "#C77DFF");
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(p.x, p.y, planetR, 0, Math.PI * 2);
                ctx.fill();
            } 
            else if (item.type === 'particle') {
                const displaySize = item.original.size * p.s;
                const grad = ctx.createLinearGradient(p.x - displaySize/2, p.y - displaySize/2, p.x + displaySize/2, p.y + displaySize/2);
                grad.addColorStop(0, "#00ffff");
                grad.addColorStop(1, "#bd00ff");
                ctx.fillStyle = grad;
                ctx.fillRect(p.x - displaySize/2, p.y - displaySize/2, displaySize, displaySize);

                if(p.s > IMAGE_SHOW_SCALE) {
                    const img = images[item.original.imgIndex];
                    if(img && img.complete) {
                        const imgSize = displaySize * 3.2;
                        ctx.drawImage(img, p.x - imgSize/2, p.y - imgSize/2, imgSize, imgSize);
                    }
                }
            } 
            else if (item.type === 'text') {
                ctx.fillStyle = "#fff";
                ctx.font = `bold ${30 * p.s}px Arial`; 
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(item.char, p.x, p.y);
            }
        });

        requestAnimationFrame(draw);
    }

    draw();
</script>

</body>
</html>