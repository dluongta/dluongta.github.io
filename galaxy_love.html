<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy Animation 3D - Dinh Luong Ta</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="galaxyCanvas"></canvas>
</div>

<script>
    const canvas = document.getElementById("galaxyCanvas");
    const container = document.getElementById("canvas-container");
    const ctx = canvas.getContext("2d");

    /* ===== 1. CẤU HÌNH (CONFIG) ===== */
    const TEXT_STR = "DINH LUONG TA";
    const imageSources = ["luen_logo.png", "hexagon-main.png", "luen-1.jpg"];

    let w, h, cx, cy;
    let zoom = 0.25; 
    const PERSPECTIVE = 1000; 
    let rotX = 1.8; 
    let rotY = 0;   

    const PLANET_RADIUS = 100; 
    const ORBIT_RADIUS = 280;  
    const ORBIT_TILT = -80;    
    const IMAGE_SHOW_SCALE = 0.8; 

    const PARTICLE_TILT_X = Math.PI / 2.3; 
    const PARTICLE_TILT_Z = Math.PI / 6;

    /* ===== 2. TẢI ẢNH ===== */
    const images = imageSources.map(src => {
        const img = new Image();
        img.src = src;
        return img;
    });

    const rand = (a, b) => Math.random() * (b - a) + a;

    /* ===== 3. RESIZE ===== */
    function resize() {
        w = canvas.width = container.clientWidth;
        h = canvas.height = container.clientHeight;
        cx = w / 2;
        cy = h / 2;
    }
    window.addEventListener("resize", resize);
    resize();

    /* ===== 4. 3D LOGIC ===== */
    function rotate3D(x, y, z) {
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);
        return { x: x2, y: y1, z: z2 };
    }

    function project(p) {
        const s = (PERSPECTIVE / (PERSPECTIVE + p.z)) * zoom;
        return { x: cx + p.x * s, y: cy + p.y * s, s, z: p.z };
    }

    /* ===== 5. KHỞI TẠO ĐỐI TƯỢNG ===== */
    const bgStars = Array.from({ length: 800 }, () => ({
        x: rand(-3000, 3000), 
        y: rand(-3000, 3000),
        z: rand(-3000, 3000), 
        size: rand(3.0, 5.0), 
        color: "#ffffff"
    }));

    const particles = [];
    const BLUE_COLOR = "#00ccff"; 
    for (let i = 0; i < 1500; i++) {
        particles.push({
            radius: rand(300, 600), 
            angle: Math.random() * Math.PI * 2,
            speed: rand(0.0005, 0.002),
            yOffset: rand(-50, 50), 
            size: rand(3, 6),
            color: BLUE_COLOR,
            imgIndex: Math.floor(Math.random() * images.length)
        });
    }

    let shootingStar = { x: -1000, y: 0, speed: 0, active: false, trailLen: 200 };
    function updateShootingStar() {
        if (!shootingStar.active) {
            if (Math.random() < 0.01) { 
                shootingStar.active = true;
                shootingStar.x = -w/2 - 200; 
                shootingStar.y = rand(-h/3, h/3);
                shootingStar.speed = rand(25, 45);
            }
        } else {
            shootingStar.x += shootingStar.speed;
            if (shootingStar.x > w/2 + 300) shootingStar.active = false;
        }
    }

    /* ===== 7. TƯƠNG TÁC (PC + MOBILE PINCH ZOOM) ===== */
    let dragging = false; 
    let lastX = 0, lastY = 0;
    let initialPinchDist = null;

    // Tính khoảng cách giữa 2 điểm chạm
    function getDistance(t1, t2) {
        return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    }

    // --- PC Events ---
    canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        zoom += e.deltaY * -0.0008;
        zoom = Math.max(0.05, Math.min(5, zoom));
    }, { passive: false });

    canvas.addEventListener("mousedown", (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        rotY += (e.clientX - lastX) * 0.003;
        rotX += (e.clientY - lastY) * 0.003;
        lastX = e.clientX; lastY = e.clientY;
    });
    window.addEventListener("mouseup", () => { dragging = false; });

    // --- Mobile Events (Xử lý zoom 2 ngón tay) ---
    canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1) {
            dragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            dragging = false; // Ngừng xoay khi đang zoom
            initialPinchDist = getDistance(e.touches[0], e.touches[1]);
        }
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
        if (e.touches.length === 1 && dragging) {
            const touch = e.touches[0];
            rotY += (touch.clientX - lastX) * 0.005;
            rotX += (touch.clientY - lastY) * 0.005;
            lastX = touch.clientX; 
            lastY = touch.clientY;
        } else if (e.touches.length === 2 && initialPinchDist) {
            e.preventDefault();
            const currentDist = getDistance(e.touches[0], e.touches[1]);
            const diff = currentDist / initialPinchDist;
            
            // Điều chỉnh zoom dựa trên tỉ lệ thay đổi khoảng cách
            zoom *= diff;
            zoom = Math.max(0.05, Math.min(5, zoom));
            
            initialPinchDist = currentDist; // Cập nhật mốc mới
        }
    }, { passive: false });

    window.addEventListener("touchend", () => { 
        dragging = false; 
        initialPinchDist = null; 
    });

    /* ===== 8. RENDERING ===== */
    function drawDynamicAura(time) {
        ctx.save();
        ctx.globalCompositeOperation = "screen";
        const lights = [
            { color: "rgba(0, 150, 255, 0.3)", angle: time * 0.8 },
            { color: "rgba(180, 0, 255, 0.3)", angle: time * 0.6 + 2 },
            { color: "rgba(255, 100, 0, 0.3)", angle: time * 0.7 + 4 }
        ];
        lights.forEach(light => {
            const radius = w * 0.25;
            const lx = cx + Math.cos(light.angle) * radius;
            const ly = cy + Math.sin(light.angle) * radius;
            const g = ctx.createRadialGradient(lx, ly, 0, lx, ly, w * 0.5);
            g.addColorStop(0, light.color);
            g.addColorStop(1, "transparent");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, w, h);
        });
        ctx.restore();
    }

    function animate() {
        let time = performance.now() * 0.0004;
        updateShootingStar();
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, w, h);
        drawDynamicAura(time);

        const renderList = [];
        renderList.push({ type: 'planet', ...rotate3D(0, 0, 0) });

        for(let i = 0; i < TEXT_STR.length; i++){
            const charAngle = time * 1.5 + (i * (Math.PI * 2 / TEXT_STR.length) * 0.5); 
            const r = rotate3D(Math.cos(charAngle) * ORBIT_RADIUS, Math.sin(charAngle) * ORBIT_TILT * 0.2, Math.sin(charAngle) * ORBIT_RADIUS);
            renderList.push({ type: 'text', char: TEXT_STR[i], ...r });
        }

        particles.forEach(p => {
            const currentA = p.angle + time + (time * p.speed * 80); 
            let px = p.radius * Math.cos(currentA), pz = p.radius * Math.sin(currentA), py = p.yOffset;
            let y1 = py * Math.cos(PARTICLE_TILT_X) - pz * Math.sin(PARTICLE_TILT_X);
            let z1 = py * Math.sin(PARTICLE_TILT_X) + pz * Math.cos(PARTICLE_TILT_X);
            let x2 = px * Math.cos(PARTICLE_TILT_Z) - y1 * Math.sin(PARTICLE_TILT_Z);
            let y2 = px * Math.sin(PARTICLE_TILT_Z) + y1 * Math.cos(PARTICLE_TILT_Z);
            renderList.push({ type: 'particle', original: p, ...rotate3D(x2, y2, z1) });
        });

        bgStars.forEach(s => renderList.push({ type: 'star', ...rotate3D(s.x, s.y, s.z), size: s.size, color: s.color }));

        renderList.sort((a, b) => b.z - a.z);

        renderList.forEach(item => {
            const p = project(item);
            if(p.s <= 0) return;

            if (item.type === 'star') {
                ctx.fillStyle = item.color;
                ctx.globalAlpha = Math.min(1, Math.max(0.1, (item.z + 3000)/5000));
                ctx.beginPath(); ctx.arc(p.x, p.y, item.size * p.s, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            } else if (item.type === 'planet') {
                const pr = PLANET_RADIUS * p.s;
                const g = ctx.createRadialGradient(p.x, p.y, pr*0.1, p.x, p.y, pr*1.8);
                g.addColorStop(0, "#fffbe6"); g.addColorStop(0.5, "#ff6600"); g.addColorStop(1, "rgba(255, 50, 0, 0)"); 
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(p.x, p.y, pr*1.8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#fff";
                ctx.beginPath(); ctx.arc(p.x, p.y, pr*0.7, 0, Math.PI*2); ctx.fill();
            } else if (item.type === 'particle') {
                if(p.s > IMAGE_SHOW_SCALE) {
                    const img = images[item.original.imgIndex];
                    if(img && img.complete) {
                        const isize = item.original.size * p.s * 8;
                        ctx.drawImage(img, p.x - isize/2, p.y - isize/2, isize, isize);
                    }
                } else {
                    const sq = item.original.size * p.s;
                    ctx.fillStyle = item.original.color;
                    ctx.globalAlpha = Math.min(1, (item.z + 2000)/3000); 
                    ctx.fillRect(p.x - sq/2, p.y - sq/2, sq, sq);
                    ctx.globalAlpha = 1;
                }
            } else if (item.type === 'text') {
                ctx.fillStyle = "#fff";
                ctx.font = `bold ${24 * p.s}px Arial`; 
                ctx.shadowColor = "#ffcc00"; ctx.shadowBlur = 10 * p.s;
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(item.char, p.x, p.y);
                ctx.shadowBlur = 0; 
            }
        });

        // Vẽ sao băng
        if(shootingStar.active) {
            const sx = cx + shootingStar.x; const sy = cy + shootingStar.y;
            const grad = ctx.createLinearGradient(sx - shootingStar.trailLen, sy, sx, sy);
            grad.addColorStop(0, "transparent"); grad.addColorStop(1, "white");
            ctx.beginPath(); ctx.moveTo(sx - shootingStar.trailLen, sy); ctx.lineTo(sx, sy);
            ctx.strokeStyle = grad; ctx.lineWidth = 3; ctx.stroke();
        }

        requestAnimationFrame(animate);
    }
    animate();
</script>

</body>
</html>