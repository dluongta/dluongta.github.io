<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy Animation 3D - Dinh Luong Ta</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="galaxyCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("galaxyCanvas");
        const container = document.getElementById("canvas-container");
        const ctx = canvas.getContext("2d");

        /* ===== 1. CẤU HÌNH (CONFIG) ===== */
        const TEXT_STR = "DINH LUONG TA";
        const imageSources = ["luen_logo.png", "hexagon-main.png", "luen-1.jpg"];

        let w, h, cx, cy;
        // let zoom = window.innerWidth < 768 ? 0.25 : 0.4;
        let zoom = window.innerWidth < 768 ? 0.15 : 0.25;
        let initialZoom = zoom;
        const PERSPECTIVE = 2000;
        let rotX = 1.8;
        let rotY = 0;

        const PLANET_RADIUS = 110;
        const ORBIT_RADIUS = 280;
        const ORBIT_TILT = -80;
        const IMAGE_SHOW_SCALE = 0.8;

        const PARTICLE_TILT_X = Math.PI / 2.3;
        const PARTICLE_TILT_Z = Math.PI / 6;
        const BLUE_COLOR = "#00ccff";
        /* ===== 1. CẤU HÌNH (CONFIG) ===== */
        // ... các dòng cũ giữ nguyên ...
        // const RINGS = [
        //     { text: "DINH ", radius: 220, tilt: -0.5, speed: 1.2, color: "#ff6200" },  // Chéo xuống phải
        //     { text: "LUONG ", radius: 320, tilt: 0.5, speed: 0.8, color: "#00ccff" },   // Chéo xuống trái
        //     { text: "TA ", radius: 420, tilt: 0, speed: 0.5, color: "#ffffff" }        // Thẳng đứng/Ngang
        // ];
        const RINGS = [
            { text: "DINH ", radius: 220, tilt: -0.8, speed: 1.2, color: "#ff6200" },  // Chéo xuống Phải
            { text: "LUONG ", radius: 320, tilt: 0.8, speed: 0.8, color: "#00ccff" },   // Chéo xuống Trái
            { text: "TA ", radius: 420, tilt: "vertical", speed: 0.5, color: "#ff0066" } // Thẳng đứng
        ];
        // --- QUẢN LÝ SAO BĂNG ---
        let shootingStar = {
            active: false,
            x: 0, y: 0,
            len: 0,
            speed: 0,
            opacity: 0
        };

        const images = imageSources.map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });

        const rand = (a, b) => Math.random() * (b - a) + a;

        function resize() {
            w = canvas.width = container.clientWidth;
            h = canvas.height = container.clientHeight;
            cx = w / 2;
            cy = h / 2;
        }
        window.addEventListener("resize", resize);
        resize();

        /* ===== 2. KHỞI TẠO ĐỐI TƯỢNG ===== */
        const bgStars = Array.from({ length: 800 }, () => ({
            x: rand(-3000, 3000), y: rand(-3000, 3000), z: rand(-3000, 3000),
            size: rand(6, 8), color: "#ffffff"
        }));

        const particles = Array.from({ length: 1500 }, () => ({
            radius: rand(500, 900),
            angle: Math.random() * Math.PI * 2,
            speed: rand(0.0005, 0.002),
            yOffset: rand(-50, 50),
            size: rand(4, 7),
            color: BLUE_COLOR,
            imgIndex: Math.floor(Math.random() * images.length)
        }));

        /* ===== 3. LOGIC SAO BĂNG NGANG (HORIZONTAL SHOOTING STAR) ===== */
        function updateShootingStar() {
            if (!shootingStar.active) {
                // Xác suất xuất hiện mỗi frame
                if (Math.random() < 0.02) {
                    shootingStar.active = true;
                    // Xuất phát từ bên trái màn hình (ngoài khung nhìn)
                    shootingStar.x = -400;
                    // Độ cao ngẫu nhiên (từ đỉnh đến giữa màn hình)
                    shootingStar.y = rand(50, h * 0.7);
                    shootingStar.len = rand(200, 400);
                    shootingStar.speed = rand(40, 60);
                    shootingStar.opacity = 1;
                }
            } else {
                // Chạy ngang (chỉ tăng X)
                shootingStar.x += shootingStar.speed;
                // Mờ dần theo chiều dài đường đi
                shootingStar.opacity -= 0.008;

                if (shootingStar.x > w + 400 || shootingStar.opacity <= 0) {
                    shootingStar.active = false;
                }
            }
        }

        function drawShootingStar() {
            if (!shootingStar.active) return;

            ctx.save();
            ctx.globalCompositeOperation = "lighter";

            // Tạo dải màu gradient cho đuôi sao băng chạy ngang
            const grad = ctx.createLinearGradient(
                shootingStar.x, shootingStar.y,
                shootingStar.x - shootingStar.len, shootingStar.y
            );
            grad.addColorStop(0, `rgba(255, 255, 255, ${shootingStar.opacity})`);
            grad.addColorStop(1, "rgba(255, 255, 255, 0)");

            ctx.strokeStyle = grad;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(shootingStar.x, shootingStar.y);
            ctx.lineTo(shootingStar.x - shootingStar.len, shootingStar.y);
            ctx.stroke();
            ctx.restore();
        }

        /* ===== 4. 3D & ZOOM LOGIC ===== */
        function rotate3D(x, y, z) {
            let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
            let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
            let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
            let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);
            return { x: x2, y: y1, z: z2 };
        }

        function project(p) {
            const s = (PERSPECTIVE / (PERSPECTIVE + p.z)) * zoom;
            return { x: cx + p.x * s, y: cy + p.y * s, s, z: p.z };
        }

        /* ===== 5. TƯƠNG TÁC (TOUCH & MOUSE) ===== */
        let dragging = false, lastX = 0, lastY = 0, initialPinchDist = null;

        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            zoom = Math.max(0.05, Math.min(4, zoom * (e.deltaY > 0 ? 0.9 : 1.1)));
        }, { passive: false });

        canvas.addEventListener("mousedown", (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener("mousemove", (e) => {
            if (!dragging) return;
            rotY += (e.clientX - lastX) * 0.004; rotX += (e.clientY - lastY) * 0.004;
            lastX = e.clientX; lastY = e.clientY;
        });
        window.addEventListener("mouseup", () => { dragging = false; });

        const getDist = (t) => Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);

        canvas.addEventListener("touchstart", (e) => {
            if (e.touches.length === 1) {
                dragging = true; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                dragging = false; initialPinchDist = getDist(e.touches); initialZoom = zoom;
            }
        }, { passive: false });

        window.addEventListener("touchmove", (e) => {
            if (e.touches.length === 1 && dragging) {
                rotY += (e.touches[0].clientX - lastX) * 0.006; rotX += (e.touches[0].clientY - lastY) * 0.006;
                lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2 && initialPinchDist) {
                e.preventDefault();
                zoom = Math.max(0.05, Math.min(4, initialZoom * (getDist(e.touches) / initialPinchDist)));
            }
        }, { passive: false });

        window.addEventListener("touchend", () => { dragging = false; initialPinchDist = null; });

        /* ===== 6. RENDERING ===== */
        function drawDynamicAura(time) {
            ctx.save();
            ctx.globalCompositeOperation = "screen";
            const lights = [
                { color: "rgba(0, 150, 255, 0.35)", angle: time * 0.5 },
                { color: "rgba(180, 0, 255, 0.35)", angle: time * 0.4 + 2 },
                { color: "rgba(255, 100, 0, 0.25)", angle: time * 0.3 + 4 }
            ];
            lights.forEach(light => {
                const orbit = w * 0.15;
                const lx = cx + Math.cos(light.angle) * orbit;
                const ly = cy + Math.sin(light.angle) * orbit;
                const g = ctx.createRadialGradient(lx, ly, 0, lx, ly, w * 0.7);
                g.addColorStop(0, light.color); g.addColorStop(1, "transparent");
                ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
            });
            ctx.restore();
        }

        function animate() {
            let time = performance.now() * 0.0004;
            ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h);

            drawDynamicAura(time);

            // Vẽ sao băng ở lớp nền
            updateShootingStar();
            drawShootingStar();

            const renderList = [];
            renderList.push({ type: 'planet', ...rotate3D(0, 0, 0) });

            // for (let i = 0; i < TEXT_STR.length; i++) {
            //     const charAngle = time * 1.5 + (i * (Math.PI * 2 / TEXT_STR.length) * 0.5);
            //     renderList.push({ type: 'text', char: TEXT_STR[i], ...rotate3D(Math.cos(charAngle) * ORBIT_RADIUS, Math.sin(charAngle) * ORBIT_TILT * 0.2, Math.sin(charAngle) * ORBIT_RADIUS) });
            // }
            // --- THAY THẾ ĐOẠN VẼ TEXT CŨ BẰNG ĐOẠN NÀY ---
            // RINGS.forEach((ring, index) => {
            //     // Tính số lượng chữ lặp lại để kín vòng tròn dựa trên bán kính
            //     const repeatCount = Math.floor(ring.radius / 15); 
            //     const fullText = ring.text.repeat(repeatCount);

            //     for (let i = 0; i < fullText.length; i++) {
            //         // Góc của từng ký tự trong vòng tròn
            //         const charAngle = (time * ring.speed) + (i * (Math.PI * 2 / fullText.length));

            //         // Tính toán vị trí 3D
            //         let x = Math.cos(charAngle) * ring.radius;
            //         let z = Math.sin(charAngle) * ring.radius;
            //         let y = Math.sin(charAngle) * ring.radius * ring.tilt; // Tạo độ chéo

            //         // Đưa vào danh sách render với thuộc tính màu riêng
            //         renderList.push({ 
            //             type: 'text', 
            //             char: fullText[i], 
            //             color: ring.color,
            //             ...rotate3D(x, y, z) 
            //         });
            //     }
            // });
            RINGS.forEach((ring) => {
                const repeatCount = Math.floor(ring.radius / 15);
                const fullText = ring.text.repeat(repeatCount);

                for (let i = 0; i < fullText.length; i++) {
                    const charAngle = (time * ring.speed) + (i * (Math.PI * 2 / fullText.length));

                    let x, y, z;

                    if (ring.tilt === "vertical") {
                        // Vòng thẳng đứng (Xoay quanh trục X)
                        x = 0;
                        y = Math.cos(charAngle) * ring.radius;
                        z = Math.sin(charAngle) * ring.radius;
                    } else {
                        // Các vòng chéo đối xứng
                        x = Math.cos(charAngle) * ring.radius;
                        z = Math.sin(charAngle) * ring.radius;
                        y = Math.cos(charAngle) * ring.radius * ring.tilt;
                    }

                    renderList.push({
                        type: 'text',
                        char: fullText[i],
                        color: ring.color,
                        ...rotate3D(x, y, z)
                    });
                }
            });

            particles.forEach(p => {
                const curA = p.angle + time + (time * p.speed * 80);
                let px = p.radius * Math.cos(curA), pz = p.radius * Math.sin(curA), py = p.yOffset;
                let y1 = py * Math.cos(PARTICLE_TILT_X) - pz * Math.sin(PARTICLE_TILT_X);
                let z1 = py * Math.sin(PARTICLE_TILT_X) + pz * Math.cos(PARTICLE_TILT_X);
                let x2 = px * Math.cos(PARTICLE_TILT_Z) - y1 * Math.sin(PARTICLE_TILT_Z);
                let y2 = px * Math.sin(PARTICLE_TILT_Z) + y1 * Math.cos(PARTICLE_TILT_Z);
                renderList.push({ type: 'particle', original: p, ...rotate3D(x2, y2, z1) });
            });

            bgStars.forEach(s => renderList.push({ type: 'star', ...rotate3D(s.x, s.y, s.z), size: s.size, color: s.color }));

            renderList.sort((a, b) => b.z - a.z);

            renderList.forEach(item => {
                const p = project(item);
                if (p.s <= 0) return;

                if (item.type === 'star') {
                    // ctx.fillStyle = item.color;
                    // ctx.globalAlpha = Math.min(1, Math.max(0.1, (item.z + 3000) / 5000));
                    // ctx.beginPath(); ctx.arc(p.x, p.y, item.size * p.s, 0, Math.PI * 2); ctx.fill();
                    // ctx.globalAlpha = 1;
                    ctx.fillStyle = item.color;
                    // Giữ hiệu ứng mờ dần theo độ sâu z
                    ctx.globalAlpha = Math.min(1, Math.max(0.1, (item.z + 3000) / 5000));

                    // --- CHỈNH SỬA TẠI ĐÂY ---
                    const s = item.size * p.s; // Kích thước sau khi tính toán phối cảnh
                    // Vẽ hình vuông: x, y, width, height
                    // Trừ đi s/2 để tâm hình vuông nằm đúng vị trí tọa độ
                    ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);

                    ctx.globalAlpha = 1;
                } else if (item.type === 'planet') {
                    const pr = PLANET_RADIUS * p.s;
                    const g = ctx.createRadialGradient(p.x, p.y, pr * 0.1, p.x, p.y, pr * 2);
                    g.addColorStop(0, "#fffbe6"); g.addColorStop(0.5, "#ff6600"); g.addColorStop(1, "transparent");
                    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, pr * 2, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(p.x, p.y, pr * 0.7, 0, Math.PI * 2); ctx.fill();
                } else if (item.type === 'particle') {
                    if (p.s > IMAGE_SHOW_SCALE) {
                        const img = images[item.original.imgIndex];
                        if (img && img.complete) {
                            const isize = item.original.size * p.s * 8;
                            ctx.drawImage(img, p.x - isize / 2, p.y - isize / 2, isize, isize);
                        }
                    } else {
                        const sq = item.original.size * p.s;
                        ctx.fillStyle = item.original.color;
                        ctx.globalAlpha = Math.min(1, (item.z + 2000) / 3000);
                        ctx.fillRect(p.x - sq / 2, p.y - sq / 2, sq, sq);
                        ctx.globalAlpha = 1;
                    }
                    // } 
                } else if (item.type === 'text') {
                    ctx.font = `bold ${30 * p.s}px Impact, Arial, sans-serif`; // Chỉnh size nhỏ lại chút cho đẹp
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    // Sử dụng màu từ item (đã truyền vào ở bước 2)
                    ctx.shadowColor = item.color;
                    ctx.shadowBlur = 10 * p.s;

                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 4 * p.s; // Giảm độ dày stroke để chữ thanh mảnh hơn
                    ctx.lineJoin = "round";
                    ctx.strokeText(item.char, p.x, p.y);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = "#ffffff";
                    ctx.fillText(item.char, p.x, p.y);
                }
            });

            requestAnimationFrame(animate);
        }
        animate();
    </script>

</body>

</html>